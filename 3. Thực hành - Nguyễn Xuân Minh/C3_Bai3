	.data
		float_arr: .float 2.4, 6.8, 5.7, 9.1, 1.3, 4.6, 3.5, 7.9, 8 , 2
		int_n: .word 10
		float_max: .word 0
		float_min: .word 0
		
		str_max: .asciiz "Max = "
		str_min: .asciiz "Min = "
		str_enter: .asciiz "\n"
		
	.text
	.globl main

# macro:
	.macro printInteger (%integer)
		addi $v0, $zero, 1
		move $a0, %integer
		syscall
	.end_macro
	
	.macro printString (%str)
		addi $v0, $zero, 4
		la $a0, %str
		syscall
	.end_macro
	
	.macro cinInteger (%int)
		li $v0, 5
		syscall 
		sw $v0, %int
	.end_macro
	
	.macro cinCharacter (%ch)
		li $v0, 12
		syscall 
		sb $v0, %ch
	.end_macro
	
	.macro printFloat(%f)
		li $v0, 2
		lwc1 $f12, %f
		syscall
	.end_macro
main:
# Nhap:
	
# xu ly:
	la $a0, float_arr
	lw $a1, int_n
	
	jal max_function
	
	printFloat(float_max)
	
# Xuat:
	
# Ket thuc:
	li $v0, 10
	syscall
	
	
#------------------------------- information function max_function----------------------------------
# Ten ham: max: tinh max
# input: $a2 = address of arr
#	$f0 = max
#`	$f1 = arr[i]
#	$s2 = i
#	$f3 = max - a[i]

# output: $v0 = range
#-----------------------------------------------------------------------------	
max_function:
	add $a2, $a0, $zero
	#---------------------------------
	lwc1 $f0, 0($a2)
	addi $s2, $zero, 1
	addi $a2, $a2, 4
	loop1:	
		beq $s2, $a1, end_loop1
		lwc1 $f1, 0($a2)
		#--------------------------
			c.lt.s $f0, $f1
			bc1f end_if1
			mov.s $f0, $f1
		end_if1:
			addi $s2, $s2, 1
			addi $a2, $a2, 4
		#--------------------------
		j loop1
	end_loop1:
		swc1 $f0, float_max
	#---------------------------------
	 jr $ra 


# Ham min chua duoc dung trong bai nay

#------------------------------- information function min_function----------------------------------
# Ten ham: max: tinh min
# input: $a2 = address of arr
#	$s0 = min
#`	$s1 = arr[i]
#	$s2 = i
#	$s3 = min - a[i]

# output: $v0 = range
#-----------------------------------------------------------------------------	
min_function:
	add $a2, $a0, $zero
	#---------------------------------
	lw $s0, 0($a2)
	addi $s2, $zero, 1
	addi $a2, $a2, 4
	loop2:	
		beq $s2, $a1, end_loop2
		lw $s1, 0($a2)
		sub $s3, $s0, $s1
		#----------------------
			bltz $s3, end_if2
			move $s0, $s1
		end_if2: 
			addi $s2, $s2, 1
			addi $a2, $a2, 4
		#-----------------------
		j loop2
	end_loop2:
		move $v0, $s0
	#---------------------------------
	 jr $ra 